#include <lvgl.h>
#include <TFT_eSPI.h>
#include "ui.h"
#include "lv_conf.h"
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <base64.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

#define LV_HOR_RES_MAX 320
#define LV_VER_RES_MAX 240

// WiFi info
const char* ssid = "faw";
const char* password = "tongpotongpo";

// Spotify client info
const char* client_id = "ee024f87dd83450d919e59e01aa8c992";
const char* client_secret = "b50894d04bfe47ac840f746def448d75";

// Spotify tokens
String spotifyAccessToken = "";
String spotifyRefreshToken = "";

// Playback state
bool playback_state = true;

// Initialize the display driver
TFT_eSPI tft = TFT_eSPI();

// Define display buffer
static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf[LV_HOR_RES_MAX * 10];

// Touchscreen variables
uint16_t touchX, touchY;
bool touched;
unsigned long last_touch_time = 0;
const unsigned long debounce_delay = 100;

// Define the button boundaries
#define LEFT_BUTTON_X_MIN  50
#define LEFT_BUTTON_X_MAX  100
#define LEFT_BUTTON_Y_MIN  160
#define LEFT_BUTTON_Y_MAX  200

#define MIDDLE_BUTTON_X_MIN  130
#define MIDDLE_BUTTON_X_MAX  170
#define MIDDLE_BUTTON_Y_MIN  160
#define MIDDLE_BUTTON_Y_MAX  200

#define RIGHT_BUTTON_X_MIN  250
#define RIGHT_BUTTON_X_MAX  300
#define RIGHT_BUTTON_Y_MIN  160
#define RIGHT_BUTTON_Y_MAX  200

// Task handles
TaskHandle_t TaskHandle_Touchscreen = NULL;
TaskHandle_t TaskHandle_LVGL = NULL;
TaskHandle_t TaskHandle_WiFi = NULL;

void setup();
void loop();
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p);
void refreshSpotifyToken();
void playSpotify();
void pauseSpotify();
void nextTrack();
void previousTrack();
void checkAndRefreshToken();

// Task functions
void Task_Touchscreen(void *pvParameters);
void Task_LVGL(void *pvParameters);
void Task_WiFi(void *pvParameters);

void setup() {
  Serial.begin(115200); // Initialize serial for debugging

  // Initialize the TFT display
  tft.begin(); 
  tft.setRotation(1); // Set the rotation to landscape

  lv_init(); // Initialize LVGL
  
  // Initialize display buffer
  lv_disp_draw_buf_init(&draw_buf, buf, NULL, LV_HOR_RES_MAX * 10);

  // Initialize display driver
  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res = LV_HOR_RES_MAX; // Use LV_HOR_RES_MAX
  disp_drv.ver_res = LV_VER_RES_MAX; // Use LV_VER_RES_MAX
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);

  // Initialize the UI generated by SquareLine
  ui_init();

  // Create tasks
  xTaskCreatePinnedToCore(Task_Touchscreen, "Touchscreen Task", 4096, NULL, 1, &TaskHandle_Touchscreen, 1);
  xTaskCreatePinnedToCore(Task_LVGL, "LVGL Task", 4096, NULL, 2, &TaskHandle_LVGL, 1);
  xTaskCreatePinnedToCore(Task_WiFi, "WiFi Task", 4096, NULL, 1, &TaskHandle_WiFi, 1);
}

void Task_Touchscreen(void *pvParameters) {
  while (1) {
    // Read touch input
    touched = tft.getTouch(&touchX, &touchY);

    if (touched && (millis() - last_touch_time > debounce_delay)) {
      last_touch_time = millis();

      if (touchX >= LEFT_BUTTON_X_MIN && touchX <= LEFT_BUTTON_X_MAX &&
          touchY >= LEFT_BUTTON_Y_MIN && touchY <= LEFT_BUTTON_Y_MAX) {
        previousTrack();
      } 
      else if (touchX >= MIDDLE_BUTTON_X_MIN && touchX <= MIDDLE_BUTTON_X_MAX &&
               touchY >= MIDDLE_BUTTON_Y_MIN && touchY <= MIDDLE_BUTTON_Y_MAX) {
        if (playback_state == false) {
          playSpotify();
          playback_state = true;
        } else {
          pauseSpotify();
          playback_state = false;
        }
      } 
      else if (touchX >= RIGHT_BUTTON_X_MIN && touchX <= RIGHT_BUTTON_X_MAX &&
               touchY >= RIGHT_BUTTON_Y_MIN && touchY <= RIGHT_BUTTON_Y_MAX) {
        nextTrack();
      }
    }

    vTaskDelay(10 / portTICK_PERIOD_MS); // Delay to allow some idle time
  }
}

void Task_LVGL(void *pvParameters) {
  while (1) {
    lv_timer_handler(); // Call LVGL task handler
    vTaskDelay(5 / portTICK_PERIOD_MS); // Delay to allow some idle time
  }
}

void Task_WiFi(void *pvParameters) {
  // Connecting to WiFi
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }

  Serial.println("Connected to WiFi");

  // Prompt for Spotify Access Token
  Serial.print("Enter Spotify Access Token: ");
  while (!Serial.available()) {
    delay(100);
  }
  spotifyAccessToken = Serial.readStringUntil('\n');
  spotifyAccessToken.trim();
  Serial.println(spotifyAccessToken);

  // Prompt for Spotify Refresh Token
  Serial.print("Enter Spotify Refresh Token: ");
  while (!Serial.available()) {
    delay(100);
  }
  spotifyRefreshToken = Serial.readStringUntil('\n');
  spotifyRefreshToken.trim();
  Serial.println(spotifyRefreshToken);

  Serial.println("Tokens set successfully!\n");

  while (1) {
    checkAndRefreshToken();
    vTaskDelay(60000 / portTICK_PERIOD_MS); // Check and refresh token every minute
  }
}

void loop() {
  // Empty loop function, as tasks are running separately
}

// Get tokens
void refreshSpotifyToken() {
  HTTPClient http;
  http.begin("https://accounts.spotify.com/api/token");

  String authString = String(client_id) + ":" + String(client_secret);
  String authBase64 = base64::encode(authString);
  http.addHeader("Authorization", "Basic " + authBase64);
  http.addHeader("Content-Type", "application/x-www-form-urlencoded");

  String postData = "grant_type=refresh_token&refresh_token=" + spotifyRefreshToken;
  int httpResponseCode = http.POST(postData);

  if (httpResponseCode == 200) {
    String response = http.getString();
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, response);
    spotifyAccessToken = doc["access_token"].as<String>();
    Serial.println("Token refreshed: " + spotifyAccessToken);
  } else {
    Serial.print("Failed to refresh token, HTTP response code: ");
    Serial.println(httpResponseCode);
  }

  http.end();
}

// Play the Spotify Playback
void playSpotify() {
  checkAndRefreshToken();
  HTTPClient http;
  http.begin("https://api.spotify.com/v1/me/player/play");
  http.addHeader("Authorization", "Bearer " + spotifyAccessToken);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Content-Length", "0");  // Explicitly add Content-Length header

  int httpResponseCode = http.PUT("");

  if (httpResponseCode == 204) {
    Serial.println("Playback started");
  } else {
    Serial.print("Failed to start playback, HTTP response code: ");
    Serial.println(httpResponseCode);
  }

  http.end();
}

// Pause the Spotify Playback
void pauseSpotify() {
  checkAndRefreshToken();
  HTTPClient http;
  http.begin("https://api.spotify.com/v1/me/player/pause");
  http.addHeader("Authorization", "Bearer " + spotifyAccessToken);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Content-Length", "0");  // Explicitly add Content-Length header

  int httpResponseCode = http.PUT("");

  if (httpResponseCode == 204) {
    Serial.println("Playback paused");
  } else {
    Serial.print("Failed to pause playback, HTTP response code: ");
    Serial.println(httpResponseCode);
  }

  http.end();
}

// Skip to the next track
void nextTrack() {
  checkAndRefreshToken();
  HTTPClient http;
  http.begin("https://api.spotify.com/v1/me/player/next");
  http.addHeader("Authorization", "Bearer " + spotifyAccessToken);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Content-Length", "0");  // Explicitly add Content-Length header

  int httpResponseCode = http.POST("");

  if (httpResponseCode == 204) {
    Serial.println("Skipped to next track");
  } else {
    Serial.print("Failed to skip to next track, HTTP response code: ");
    Serial.println(httpResponseCode);
  }

  http.end();
}

// Skip to the previous track
void previousTrack() {
  checkAndRefreshToken();
  HTTPClient http;
  http.begin("https://api.spotify.com/v1/me/player/previous");
  http.addHeader("Authorization", "Bearer " + spotifyAccessToken);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Content-Length", "0");  // Explicitly add Content-Length header

  int httpResponseCode = http.POST("");

  if (httpResponseCode == 204) {
    Serial.println("Skipped to previous track");
  } else {
    Serial.print("Failed to skip to previous track, HTTP response code: ");
    Serial.println(httpResponseCode);
  }

  http.end();
}

// Check the token
void checkAndRefreshToken() {
  HTTPClient http;
  http.begin("https://api.spotify.com/v1/me");
  http.addHeader("Authorization", "Bearer " + spotifyAccessToken);
  int httpResponseCode = http.GET();

  if (httpResponseCode == 401) { // Unauthorized
    Serial.println("Access token expired, refreshing...");
    refreshSpotifyToken();
  } else if (httpResponseCode != 200) { // Any other error code
    Serial.print("Failed to validate token, HTTP response code: ");
    Serial.println(httpResponseCode);
  } else {
    Serial.println("Access token is valid.");
  }

  http.end();
}

void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  // Copy the buffer to the display
  tft.startWrite();
  tft.setAddrWindow(area->x1, area->y1, area->x2 - area->x1 + 1, area->y2 - area->y1 + 1);
  tft.pushColors((uint16_t*)&color_p->full, (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1), true);
  tft.endWrite();
  lv_disp_flush_ready(disp);
}